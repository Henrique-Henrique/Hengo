@tool
class_name HenCodeGeneration extends Node

# references
static var _name_list: Array = []
static var _name_counter: int = 0
static var _name_ref: Dictionary = {}
# debug
static var _debug_counter: float = 1.
static var _debug_symbols: Dictionary = {}


static func _provide_params_ref(_params: Array, _prefix: StringName) -> Array:
	if _params.size() > 0:
		var first: Dictionary = _params[0]

		print('jj ', first)

		if first.has('is_ref'):
			return [
				_params.slice(1),
				parse_token_by_type(first)
			]
	
	return [_params, _prefix]


static func _get_signal_call_name(_name: String) -> String:
	return '_on_' + _name.to_snake_case() + '_signal_'

#
#
#
static func generate_and_save(_compile_ref: HBoxContainer) -> void:
	var start: float = Time.get_ticks_usec()
	HenSaver.save(generate(), _debug_symbols)
	var end: float = Time.get_ticks_usec()
	
	print('GENERATED AND SAVED HENGO SCRIPT IN -> ', (end - start) / 1000, 'ms.')

	HenGlobal.current_script_debug_symbols = _debug_symbols


static func generate() -> String:
	# reseting internal variables
	_name_list = []
	_name_counter = 0
	_name_ref = {}
	_debug_counter = 1.
	_debug_symbols = {}

	var code: String = '# ***************************************************************
# *                 CREATED BY HENGO VISUAL SCRIPT              *
# *    This file is automatically generated and maintained by   *
# *               the Hengo Visual Script tool.                 *
# *       Edit only if you are confident in your changes.       *
# ***************************************************************\n\nextends {0}\n\n'.format([HenGlobal.script_config.type])

	# variables
	var var_code: String =' # Variables #\n'

	for var_data: HenSideBar.VarData in HenGlobal.SIDE_BAR_LIST.var_list:
		var_code += generate_var_code(var_data)

	code += var_code
	# end variables

	var start_state: HenVirtualCNode
	var states_data: Dictionary = {}
	var events: Array[Dictionary] = []

	# getting states
	for v_cnode: HenVirtualCNode in HenGlobal.BASE_ROUTE.ref.virtual_cnode_list:
		match v_cnode.sub_type:
			# getting start state cnode
			HenVirtualCNode.SubType.STATE_START:
				start_state = v_cnode.flow_connections[0].to
			HenVirtualCNode.SubType.STATE:
				var transitions: Array = []

				# getting transition
				for flow_connection: HenVirtualCNode.FlowConnectionData in v_cnode.flow_connections:
					if flow_connection.to:
						transitions.append({
							name = flow_connection.name,
							to_state_name = flow_connection.to.name
						})

				states_data[v_cnode.name.to_snake_case()] = {
					virtual_tokens = parse_tokens(v_cnode.virtual_sub_type_vc_list),
					transitions = transitions
				}
			HenVirtualCNode.SubType.STATE_EVENT:
				if v_cnode.flow_connections[0].to:
					events.append({
						name = v_cnode.name,
						to_state_name = v_cnode.flow_connections[0].to.name
					})

	# base template
	#TODO not all nodes has _process or _physics_process, make more dynamic
	var base_template = """\nvar _STATE_CONTROLLER = HengoStateController.new()

const _EVENTS ={events}

func _init() -> void:
	_STATE_CONTROLLER.set_states({
{states_dict}
	})

func _ready() -> void:
	if not _STATE_CONTROLLER.current_state:
		_STATE_CONTROLLER.change_state("{start_state_name}")

func trigger_event(_event: String) -> void:
	if _EVENTS.has(_event):
		_STATE_CONTROLLER.change_state(_EVENTS[_event])

func _process(delta: float) -> void:
	_STATE_CONTROLLER.static_process(delta)

func _physics_process(delta: float) -> void:
	_STATE_CONTROLLER.static_physics_process(delta)
""".format({
		events = ' { \n\t' + ',\n\t'.join(events.map(
			func(ev: Dictionary) -> String:
			return '{event_name}="{to_state_name}"'.format({
				event_name = ev.name.to_snake_case(),
				to_state_name = ev.to_state_name.to_snake_case()
			})
			)) + '\n}' if not events.is_empty() else '{}',
		start_state_name = start_state.name.to_snake_case(),
	})

	# functions
	var func_code: String = '\n# Functions\n'

	for func_data: HenSideBar.FuncData in HenGlobal.SIDE_BAR_LIST.func_list:
		# generating function
		func_code += 'func {name}({params}):\n'.format({
			name = func_data.name.to_snake_case(),
			params = ', '.join(func_data.inputs.map(
				func(x: HenSideBar.Param) -> String:
					return x.name.to_snake_case()
		))
		})

		# debug
		# func_code += '\t' + get_debug_var_start()
		
		# local variable
		func_code += '\n'.join(func_data.local_vars.map(func(x: HenSideBar.VarData):
			return '\t' + generate_var_code(x))) + '\n'

		# func output (return)
		var output_code: Array = []
		
		for token: Dictionary in func_data.output_ref.get_input_token_list():
			output_code.append(parse_token_by_type(token))

		if func_data.input_ref.flow_connections[0].to:
			var func_tokens: Array = func_data.input_ref.flow_connections[0].to.get_flow_token_list()
			var func_block: Array = []

			for token in func_tokens:
				func_block.append(parse_token_by_type(token, 1))

			# debug
			# func_block.append(parse_token_by_type(
			# 	get_debug_token(func_data.virtual_cnode_list[0]),
			# 	1
			# ))

			func_code += '\n'.join(func_block) + '\n'
			func_code += '\t' + get_debug_push_str() + '\n'
		else:
			func_code += '\tpass\n\n' if func_data.local_vars.is_empty() and output_code.is_empty() else ''
		
	# 	#TODO output when not connected return empty field, make a default values for all types
		if output_code.size() == 1:
			func_code += '\treturn {output}\n\n'.format({
				output = ', '.join(output_code)
			})
		elif not output_code.is_empty():
			func_code += '\treturn [{outputs}]\n\n'.format({
				outputs = ', '.join(output_code)
			})
		
		func_code += '\n'
		# end func output
	
	base_template += func_code + '\n\n'
	# end functions

	# signal callables
	var signal_code: String = '#\n\n# Signals Callables\n'


	for signal_item: HenSideBar.SignalData in HenGlobal.SIDE_BAR_LIST.signal_list:
		var signal_name = _get_signal_call_name(signal_item.name)

		signal_code += 'func {name}({params}):\n'.format({
			name = signal_name,
			params = ', '.join(signal_item.params.map( # parsing raw inputs from signal
			func(x: HenSideBar.Param) -> String:
				return x.name.to_snake_case()
		# parsing custom inputs
		) + signal_item.bind_params.map(
				func(x: HenSideBar.Param) -> String:
					return x.name.to_snake_case()
		))
		})

		# local variable
		signal_code += '\n'.join(signal_item.local_vars.map(func(x: HenSideBar.VarData):
			return '\t' + generate_var_code(x))) + '\n'

		# debug
		# signal_code += '\t' + get_debug_var_start()


		if signal_item.signal_enter.flow_connections[0].to:
			var signal_tokens: Array = signal_item.signal_enter.flow_connections[0].to.get_flow_token_list()
			var signal_block: Array = []

			for token in signal_tokens:
				signal_block.append(parse_token_by_type(token, 1))

			# debug
			# signal_block.append(parse_token_by_type(
			# 	get_debug_token(signal_item.virtual_cnode_list[0]),
			# 	1
			# ))

			signal_code += '\n'.join(signal_block) + '\n\n'
			signal_code += '\t' + get_debug_push_str() + '\n\n\n'
		else:
			signal_code += '\tpass\n\n'
	
	base_template += signal_code
	# end signal callables


	# parsing base template
	# adding states and transitions
	base_template = base_template.format({
		states_dict = ',\n'.join(states_data.keys().map(
			func(state_name: String) -> String:
				return '\t\t{key}={c_name}.new(self{transitions})'.format({
					key = state_name,
					c_name = state_name.to_pascal_case(),
					transitions = ', {\n\t\t\t' + ',\n\t\t\t'.join(states_data[state_name].transitions.map(
					func(trans: Dictionary) -> String:
					return '{state_name}="{to_state_name}"'.format({
						state_name = trans.name.to_snake_case(),
						to_state_name = trans.to_state_name.to_snake_case()
					})
					)) + '\n\t\t}' if states_data[state_name].transitions.size() > 0 else ''
				})
	)),
		first_state = states_data.keys()[0]
	})

	code += base_template

	# generating classes implementation
	for state_name in states_data.keys():
		var item = states_data[state_name]

		var base = 'class {name} extends HengoState:\n'.format({
			name = state_name.to_pascal_case()
		})

		if item.virtual_tokens.is_empty():
			base += '\tpass\n\n'
			code += base
			continue

		for virtual_name in item.virtual_tokens.keys():
			var func_tokens = item.virtual_tokens[virtual_name].tokens
			var func_params = item.virtual_tokens[virtual_name].params

			if func_tokens.is_empty():
				continue

			var func_base: String = '\tfunc {name}({params}) -> void:\n'.format({
				name = virtual_name,
				params = ', '.join(func_params.map(
					func(x: Dictionary) -> String:
						return x.name
			))
			})

			var func_codes: Array = []

			for token in func_tokens:
				func_codes.append(
					parse_token_by_type(token, 2)
				)
			
			func_base += '\n'.join(func_codes) + '\n\n'
			base += func_base

		code += base + '\n\n'

	return code


static func parse_tokens(_virtual_cnode_list: Array) -> Dictionary:
	var data: Dictionary = {}

	for virtual_cnode: HenVirtualCNode in _virtual_cnode_list:
		var cnode_name: String = virtual_cnode.name
		var from_flow: HenVirtualCNode.FlowConnectionData = virtual_cnode.flow_connections[0]

		if from_flow.to:
			var token_list = from_flow.to.get_flow_token_list()
			# token_list.append(get_debug_token(virtual_cnode))
			# token_list.append(get_push_debug_token())

			# if cnode_name == 'enter':
			# 	token_list.append({type = HenCnode.SUB_TYPE.DEBUG_STATE, id = 99})
			
			data[cnode_name] = {
				tokens = token_list,
				params = virtual_cnode.get_output_token_list()
			}
		else:
			if cnode_name == 'enter':
				data[cnode_name] = {
					tokens = [ {type = HenCnode.SUB_TYPE.PASS, use_self = false}],
					params = []
				}

	return data


static func generate_var_code(_var_data: HenSideBar.VarData) -> String:
	var var_code: String = ''
	var type_value: String = 'null'

	if HenEnums.VARIANT_TYPES.has(_var_data.type):
		if _var_data.type == 'Variant':
			type_value = 'null'
		else:
			type_value = _var_data.type + '()'
	elif ClassDB.can_instantiate(_var_data.type):
		type_value = _var_data.type + '.new()'

	var_code += '{export_var}var {name} = {value}\n'.format({
		name = _var_data.name.to_snake_case(),
		value = type_value,
		export_var = '@export ' if _var_data.export else ''
	})

	return var_code

#
#
# parse to code
static func parse_token_by_type(_token: Dictionary, _level: int = 0) -> String:
	var indent: StringName = '\t'.repeat(_level)
	var prefix: StringName = '_ref.'

	print('yy ', _token)

	if _token.use_self == true or (_token.has('category') and _token.get('category') == 'native'):
		prefix = ''


	match _token.type as HenCnode.SUB_TYPE:
		HenCnode.SUB_TYPE.VAR:
			return indent + prefix + _token.name
		HenCnode.SUB_TYPE.SET_VAR:
			return indent + prefix + '{name} = {value}'.format({
				name = _token.name,
				value = parse_token_by_type(_token.value)
			})
		HenCnode.SUB_TYPE.SET_LOCAL_VAR:
			return indent + '{name} = {value}'.format({
				name = _token.name,
				value = parse_token_by_type(_token.value)
			})
		HenCnode.SUB_TYPE.LOCAL_VAR:
			return indent + _token.name
		HenCnode.SUB_TYPE.IN_PROP:
			if _token.has('is_ref'):
				if _token.use_self: return indent
				else: return indent + prefix
				
			if _token.has('use_value'):
				if _token.use_self: return indent + _token.value
				else: return indent + prefix + _token.value

			if _token.has('use_prefix'):
				return indent + prefix + _token.value

			if _token.has('is_prop') and _token.get('is_prop') == true:
				return indent + prefix + _token.value

			return indent + str(_token.value)
		HenCnode.SUB_TYPE.VOID, HenCnode.SUB_TYPE.GO_TO_VOID, HenCnode.SUB_TYPE.SELF_GO_TO_VOID:
			var values: Array = _provide_params_ref(_token.params, prefix)
			var params: Array = values[0]

			prefix = values[1]

			var selfInput: String = ''

			if _token.type == HenCnode.SUB_TYPE.SELF_GO_TO_VOID:
				selfInput = 'self, '

			return indent + prefix + '{name}({params})'.format({
				name = _token.name,
				params = selfInput + ', '.join(params.map(
					func(x: Dictionary) -> String:
						return parse_token_by_type(x)
			))
			})
		HenCnode.SUB_TYPE.FUNC, HenCnode.SUB_TYPE.USER_FUNC, HenCnode.SUB_TYPE.SINGLETON:
			var values: Array = _provide_params_ref(_token.params, prefix)
			var params: Array = values[0]
			
			prefix = values[1]

			if _token.type == HenCnode.SUB_TYPE.SINGLETON:
				prefix = ''

			return indent + prefix + '{name}({params}){id}'.format({
				name = _token.name,
				id = '[{0}]'.format([_token.id]) if _token.id >= 0 else '',
				params = ', '.join(params.map(
					func(x: Dictionary) -> String:
						return parse_token_by_type(x)
			))
			})
		HenCnode.SUB_TYPE.VIRTUAL, HenCnode.SUB_TYPE.FUNC_INPUT:
			return _token.param
		HenCnode.SUB_TYPE.IF:
			var base: String = 'if {condition}:\n'.format({
				condition = parse_token_by_type(_token.condition)
			})
			var code_list: Array = []

			if _token.true_flow.is_empty():
				base += indent + '\tpass\n'
			else:
				for token in _token.true_flow:
					code_list.append(
						parse_token_by_type(token, _level + 1)
					)

			
			code_list.append('')

			for token in _token.false_flow:
				code_list.append(
					parse_token_by_type(token, _level)
				)

			if code_list.is_empty():
				if not _token.true_flow.is_empty():
					base += indent + '\tpass'
			else:
				base += '\n'.join(code_list) + '\n\n'
		
			return '\n' + indent + base
		HenCnode.SUB_TYPE.NOT_CONNECTED:
			return 'null'
		HenCnode.SUB_TYPE.FOR, HenCnode.SUB_TYPE.FOR_ARR:
			var flow: Array = []
			var loop_item: String = get_sequence_name('loop_idx') if _token.type == HenCnode.SUB_TYPE.FOR else get_sequence_name('loop_item')

			_name_ref[_token.hash] = loop_item

			if _token.flow.size() <= 0:
				flow.append(indent + '\tpass')

			for token in _token.flow:
				flow.append(parse_token_by_type(token, _level + 1))
			
			if _token.type == HenCnode.SUB_TYPE.FOR:
				return indent + 'for {item_name} in range({params}):\n{flow}'.format({
					flow = '\n'.join(flow),
					item_name = loop_item,
					params = ', '.join(_token.params.map(
						func(x: Dictionary) -> String:
							return parse_token_by_type(x)
				))
				})
			else:
				return indent + 'for {item_name} in {arr}:\n{flow}'.format({
					flow = '\n'.join(flow),
					item_name = loop_item,
					arr = parse_token_by_type(_token.params[0])
				})
		HenCnode.SUB_TYPE.FOR_ITEM:
			return _name_ref[_token.hash]
		HenCnode.SUB_TYPE.BREAK:
			# TODO check break and continue if is inside for loop
			return indent + 'break'
		HenCnode.SUB_TYPE.CONTINUE:
			return indent + 'continue'
		# HenCnode.SUB_TYPE.CAST:
		# 	var from = parse_token_by_type(_token.from)

		# 	if from == 'null':
		# 		return prefix.replace('.', '')

		# 	return '(({from}) as {to})'.format({
		# 		from = from,
		# 		to = _token.to
		# 	})
		HenCnode.SUB_TYPE.IMG:
			return '{a} {op} {b}'.format({
				a = parse_token_by_type(_token.params[0]),
				op = _token.name,
				b = parse_token_by_type(_token.params[1])
			})
		HenCnode.SUB_TYPE.DEBUG:
			return indent + HenGlobal.DEBUG_TOKEN + HenGlobal.DEBUG_VAR_NAME + ' += ' + str(_token.counter)
		HenCnode.SUB_TYPE.DEBUG_PUSH:
			return indent + get_debug_push_str()
		HenCnode.SUB_TYPE.DEBUG_FLOW_START:
			return indent + get_debug_var_start()
		HenCnode.SUB_TYPE.DEBUG_STATE:
			return indent + HenGlobal.DEBUG_TOKEN + "EngineDebugger.send_message('hengo:debug_state', [" + str(_token.id) + "])"
		HenCnode.SUB_TYPE.START_DEBUG_STATE:
			return indent + "EngineDebugger.send_message('hengo:debug_state', [" + str(_token.id) + "])"
		HenCnode.SUB_TYPE.DEBUG_VALUE:
			return indent + HenGlobal.DEBUG_TOKEN + "EngineDebugger.send_message('hengo:debug_value', [" + str(_token.id) + ", var_to_str(" + parse_token_by_type(_token.value) + ")])"
		HenCnode.SUB_TYPE.PASS:
			return indent + 'pass'
		HenCnode.SUB_TYPE.RAW_CODE:
			return _token.code.value.trim_prefix('"').trim_suffix('"')
		HenCnode.SUB_TYPE.SINGLETON:
			return indent + _token.name
		HenCnode.SUB_TYPE.GET_PROP:
			if not _token.has('data'): return indent + prefix + _token.value
			return indent + parse_token_by_type(_token.data) + '.' + _token.value
		HenCnode.SUB_TYPE.SET_PROP:
			print('== ', _token)
			if not _token.has('data'): return indent + prefix + _token.name + ' = ' + parse_token_by_type(_token.value)
			return indent + parse_token_by_type(_token.data) + '.' + _token.name + ' = ' + parse_token_by_type(_token.value)
		HenCnode.SUB_TYPE.EXPRESSION:
			var new_exp: String = _token.exp
			var reg: RegEx = RegEx.new()

			for param in _token.params.slice(1):
				reg.compile("\\b" + param.prop_name + "\\b")
				new_exp = reg.sub(new_exp, parse_token_by_type(param), true)
			
			return new_exp
		HenVirtualCNode.SubType.SIGNAL_CONNECTION:
			var values: Array = _provide_params_ref(_token.params, prefix)
			var params: Array = values[0]
			var my_prefix = values[1]

			print('yyyy ', params)

			if not params.is_empty():
				return indent + '{ref}connect("{signal_name}", {call_ref}{callable}.bind({params}))'.format({
					ref = my_prefix,
					params = ', '.join(params.map(func(x: Dictionary) -> String:
						return parse_token_by_type(x))),
					signal_name = _token.signal_name,
					call_ref = prefix,
					callable = _get_signal_call_name(_token.name)
				})

			return indent + '{ref}connect("{signal_name}", {call_ref}{callable})'.format({
				ref = my_prefix,
				signal_name = _token.signal_name,
				call_ref = prefix,
				callable = _get_signal_call_name(_token.name)
			})
		HenVirtualCNode.SubType.SIGNAL_DISCONNECTION:
			var values: Array = _provide_params_ref(_token.params, prefix)
			var params: Array = values[0]
			var my_prefix = values[1]

			return indent + '{ref}disconnect("{signal_name}", {call_ref}{callable})'.format({
				ref = my_prefix,
				signal_name = _token.signal_name,
				call_ref = prefix,
				callable = _get_signal_call_name(_token.name)
			})
		_:
			return ''


static func get_sequence_name(_name: String) -> String:
	if _name_list.has(_name):
		_name_counter += 1
		var new_name = _name + '_' + str(_name_counter)
		_name_list.append(new_name)
		return new_name

	_name_list.append(_name)
	return _name


static func get_debug_token(_node: HenVirtualCNode, _flow: String = 'cnode') -> Dictionary:
	_debug_counter *= 2.
	_debug_symbols[str(_debug_counter)] = [_node.id, _flow]
	return {type = HenCnode.SUB_TYPE.DEBUG, counter = _debug_counter}


static func get_debug_counter(_node: HenCnode) -> float:
	_debug_counter *= 2.
	_debug_symbols[str(_debug_counter)] = [_node.hash]
	return _debug_counter


# static func get_state_debug_counter(_state: HenVirtualState) -> float:
# 	_debug_counter *= 2.
# 	_debug_symbols[str(_debug_counter)] = [_state.id]
# 	return _debug_counter


static func get_push_debug_token() -> Dictionary:
	return {type = HenCnode.SUB_TYPE.DEBUG_PUSH}


static func get_debug_flow_start_token() -> Dictionary:
	return {type = HenCnode.SUB_TYPE.DEBUG_FLOW_START}


static func get_debug_var_start() -> String:
	return HenGlobal.DEBUG_TOKEN + 'var ' + HenGlobal.DEBUG_VAR_NAME + ': float = 0.\n'


static func get_debug_push_str() -> String:
	return HenGlobal.DEBUG_TOKEN + "EngineDebugger.send_message('hengo:cnode', [" + HenGlobal.DEBUG_VAR_NAME + "])"